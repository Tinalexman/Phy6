package dream.camera;

import dream.constants.GlobalConstants;
import dream.ecs.entities.Node;
import dream.io.output.Window;
import org.joml.Matrix4f;
import org.joml.Vector3f;

public class Camera extends Node
{
    protected Vector3f cameraRotation; // pitch = about x  yaw = about y roll = about z
    protected Vector3f cameraPosition;
    protected Vector3f upVector;
    protected Vector3f cameraFront;
    protected float cameraZoom;
    protected boolean hasChanged;
    protected float nearPlane;
    protected float farPlane;
    protected boolean active;

    protected Matrix4f inverseViewMatrix;
    protected Matrix4f inverseProjectionMatrix;
    protected Matrix4f viewMatrix;
    protected Matrix4f projectionMatrix;

    private static Camera CURRENT_CAMERA;

    private void getCameraDirection()
    {
        Vector3f cameraDirection = new Vector3f();
        cameraDirection.x = (float) (Math.cos(Math.toRadians(this.cameraRotation.y)) * Math.cos(Math.toRadians(this.cameraRotation.x)));
        cameraDirection.y = (float) (Math.sin(Math.toRadians(this.cameraRotation.x)));
        cameraDirection.z = (float) (Math.sin(Math.toRadians(this.cameraRotation.y)) * Math.cos(Math.toRadians(this.cameraRotation.x)));
        cameraDirection.normalize(this.cameraFront);
    }

    public Camera()
    {
        this.cameraPosition = new Vector3f(0.0f, 0.0f, 5.0f);
        this.cameraFront = new Vector3f(0.0f, 0.0f, -1.0f);
        this.upVector = new Vector3f(0.0f, 1.0f, 0.0f);

        this.cameraZoom = GlobalConstants.DEFAULT_CAMERA_MAX_ZOOM;
        this.cameraRotation = new Vector3f(0.0f, -90.0f, 0.0f);
        this.hasChanged = true;
        this.active = false;
        this.nearPlane = GlobalConstants.DEFAULT_EDITOR_CAMERA_NEAR_PLANE;
        this.farPlane = GlobalConstants.DEFAULT_EDITOR_CAMERA_FAR_PLANE;

        this.inverseViewMatrix = new Matrix4f().identity();
        this.inverseProjectionMatrix = new Matrix4f().identity();

        this.name = "Camera";
    }

    public static Camera getCurrentCamera()
    {
        return CURRENT_CAMERA;
    }

    public void requestActivation()
    {
        CURRENT_CAMERA = this;
    }

    public Matrix4f getViewMatrix()
    {
        if(hasChanged)
        {
            this.viewMatrix = new Matrix4f().identity();
            Vector3f test = new Vector3f();
            this.cameraPosition.add(cameraFront, test);
            this.viewMatrix.lookAt(this.cameraPosition, test, this.upVector);

            this.viewMatrix.invert(this.inverseViewMatrix);
        }
        return viewMatrix;
    }

    public Matrix4f getProjectionMatrix()
    {
        if(hasChanged)
        {
            this.projectionMatrix = new Matrix4f().identity();
            this.projectionMatrix.perspective(getFieldOfView(), (float) (Window.getWindowWidth() / Window.getWindowHeight()),
                    getNearPlane(), getFarPlane());
            this.projectionMatrix.invert(this.inverseProjectionMatrix);
        }
        return this.projectionMatrix;
    }

    public Matrix4f getInverseViewMatrix()
    {
        return this.inverseViewMatrix;
    }

    public Matrix4f getInverseProjectionMatrix()
    {
        return this.inverseProjectionMatrix;
    }

    public float getFieldOfView()
    {
        return this.cameraZoom;
    }

    public float getNearPlane()
    {
        return this.nearPlane;
    }

    public float getFarPlane()
    {
        return this.farPlane;
    }

    public void setNearPlane(float nearPlane)
    {
        this.nearPlane = nearPlane;
    }

    public void setFarPlane(float farPlane)
    {
        this.farPlane = farPlane;
    }

    public void setUpVector(Vector3f upVector)
    {
        this.upVector = upVector;
    }

    public Vector3f getPosition()
    {
        return this.cameraPosition;
    }

    public void setPosition(Vector3f position)
    {
        if(!this.cameraPosition.equals(position))
        {
            this.hasChanged = true;
            this.cameraPosition.set(position);
        }
    }

    public void incrementCameraZoom(float zoom)
    {
        this.cameraZoom += zoom;
    }

    public float getCameraZoom()
    {
        return this.cameraZoom;
    }

    public void setCameraZoom(float zoom)
    {
        this.cameraZoom = zoom;
    }

    public boolean hasChanged()
    {
        return hasChanged;
    }

    public void resetChange()
    {
        this.hasChanged = false;
    }

    public void hasChanged(boolean hasChanged)
    {
        this.hasChanged = hasChanged;
    }
}
